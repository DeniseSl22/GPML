<?xml version="1.0" encoding="utf-8"?>
<xsd:schema targetNamespace="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
	xmlns="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
	xmlns:xsd="http://www.w3.org/2001/XMLSchema" 
 	xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
	xml:base="http://www.w3.org/1999/02/22-rdf-syntax-ns"
	>

	<!--
	Taken from https://www.w3.org/2000/07/rdf.xsd
	  <annotation>
	    <documentation>
	      <div xmlns="http://www.w3.org/1999/xhtml">
				<h1>XML Schema for RDF</h1>
	<p>$Id: rdf.xsd,v 1.17 2000/08/04 14:37:44 swick Exp $</p>

	<p>originally derived from <a
	href="http://www.oasis-open.org/cover/xmlSchemaForRDF.html">Rick J's
	work</a>:
	</p>

	<pre>
	From:      Rick JELLIFFE &lt;ricko@allette.com.au>
	To:        xml-dev@xml.org
	Subject:   Re: new public working draft of XML Schema
	Date:      Sat, 26 Feb 2000 23:05:20 +0800
	</pre>

	<p>then modified to match 
	<a href="http://www.w3.org/TR/1999/REC-rdf-syntax-19990222/#grammar">the RDF formal grammar</a></p>

	<blockquote>
				<p>created 2000-12-25,               <br />
				Rick Jelliffe,
	<br />
				Academia Sinica Computing Centre.  <br />
				Thanks to Henry Thompson for help.  </p>
				<p>RDF Specification at
				<a href="http://www.w3.org/TR">W3C</a>.
				</p>
	</blockquote>
	</div>
			</documentation>
	 </annotation>
	-->


  <!-- Top-level of RDF Document -->
  <xsd:element name="RDF">
    <xsd:complexType>
      <xsd:sequence  maxOccurs="unbounded" >
        <xsd:group ref="obj"/> <!-- abstract -->
      </xsd:sequence>
    </xsd:complexType>
  </xsd:element>

  <xsd:group name="obj">
    <xsd:choice>
      <xsd:element ref="typedNode"/>
      <xsd:group ref="container"/>
    </xsd:choice>
  </xsd:group>

  <!-- @@check this after doing typednode -->
  <xsd:element name="Description"
           type="typedNodeType" />


  <xsd:group name="container">
    <!-- @@ spec says you can subclass this, but that
         makes parsing depend on schema info. Bad. -->
    <xsd:choice>
      <xsd:element ref="Bag"/>
      <xsd:element ref="Seq"/>
      <xsd:element ref="Alt"/>
    </xsd:choice>
  </xsd:group>

  <xsd:attributeGroup name="idAboutAttrOpt">
    <!--
    <annotation><documentation source="http://www.w3.org/TR/1999/REC-rdf-syntax-19990222/#aboutAttr"/></annotation>
    -->
    <xsd:attributeGroup ref="aboutAttrOpt"/>
    <xsd:attributeGroup ref="idAttrOpt"/>
    <!-- @@leave out aboutEachAttr for now -->

  </xsd:attributeGroup>

  <xsd:attribute name="ID" type="xsd:ID" />
  <!--
  -->

  <xsd:attributeGroup name="idAttrOpt">
    <xsd:attribute ref="ID" use='optional'/>
  </xsd:attributeGroup>

  <xsd:attribute name="about" type="xsd:anyURI" />
  <xsd:attributeGroup name="aboutAttrOpt">
    <xsd:attribute name="about" use='optional' type="xsd:anyURI" />
    <xsd:attribute ref="about" use='optional' />
  </xsd:attributeGroup>

  <!-- leaving out aboutEachAttr for now @@-->

  <!-- leaving out bagIdAttr @@-->

  <!-- leaving out propAttr @@-->

  <!-- leaving out typeAttr @@-->

  <xsd:element name="propertyElt" abstract="true"
           type="propertyEltType" />

  <xsd:complexType name="propertyEltType">
    <!--
    <annotation><documentation>this is a "union type"; use
    xsi:type in the instance to discriminate between concrete subtypes
    </documentation></annotation>
    -->
  </xsd:complexType>

  <xsd:complexType name="propertyEltValue">
    <xsd:attributeGroup ref="idAttrOpt"/>
  </xsd:complexType>

  <xsd:complexType name="propertyEltLiteral">
    <xsd:sequence>
      <xsd:any minOccurs="0" processContents="skip"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="idAttrOpt"/>
    <xsd:attributeGroup ref="parseLiteral"/>
  </xsd:complexType>

  <xsd:complexType name="propertyEltResource">
    <xsd:sequence maxOccurs="unbounded" >
      <xsd:element ref="propertyElt"   /><!--abstract !-->
    </xsd:sequence>
  </xsd:complexType>

  <xsd:complexType name="propertyEltRef">
    <xsd:attributeGroup ref="idRefAttrOpt"/>
    <!-- @@leaving out bagIdAttr? -->
    <!-- @@leaving out propAttr* -->
  </xsd:complexType>

  <xsd:element name="typedNode" abstract="true"
	   type="typedNodeType"/>

  <xsd:complexType name="typedNodeType">
    <xsd:sequence maxOccurs="unbounded">
      <xsd:element ref="propertyElt"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="idAboutAttrOpt"/>
    <!--@@leaving out bagidattr, propattr -->
  </xsd:complexType>

  <xsd:attributeGroup name="idRefAttrOpt">
    <xsd:attributeGroup ref="idAttrOpt"/>
    <xsd:attributeGroup ref="resourceAttrOpt"/>
  </xsd:attributeGroup>

 <!--@@ can complex types be abstract? or just elements? -->
  <xsd:complexType name="value" abstract="true"/>

  <xsd:complexType name="valueObj">
    <xsd:group ref="obj"/>
  </xsd:complexType>

  <xsd:complexType name="valueString">
    <xsd:sequence/> <!-- no subelements -->
  </xsd:complexType>

  <xsd:attribute name="resource" type="xsd:anyURI" />
  <xsd:attributeGroup name="resourceAttrOpt">
    <xsd:attribute name="resource" use='optional' type="xsd:anyURI" />
    <xsd:attribute ref="resource" use='optional' />
  </xsd:attributeGroup>

  <xsd:attributeGroup name="resourceAttr">
    <!-- @@er... which one to require? -->
    <xsd:attribute name="resource" use='optional' type="xsd:anyURI" />
    <xsd:attribute ref="resource" use='optional' />
  </xsd:attributeGroup>

  <xsd:element name="Seq" type="members"/>
  <xsd:element name="Bag" type="members"/>
  <xsd:element name="Alt" type="members"/>
  <!-- @@restrict Alt to have at least one member -->

  <xsd:complexType name="members">
    <xsd:sequence maxOccurs="unbounded">
      <xsd:element name="li" type="item"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="idAttrOpt"/>
    <!-- @@leaving out memberAttr* -->
  </xsd:complexType>

  <xsd:complexType name="item">
    <!--
    <annotation><documentation>this is a "union type"; use
    xsi:type in the instance to discriminate between concrete subtypes.
    @@hmm... can I mark this as "abstract" somehow?
    </documentation></annotation>
    -->
  </xsd:complexType>

  <xsd:complexType name="referencedItem">
   <xsd:attributeGroup ref="resourceAttr"/>
  </xsd:complexType>

  <!-- @@strictly speaking, inlineItem should be
       specified as subtypes, one of propertyEltValue,
       propertyEltLiteral, and propertyEltResource,
       with use="prohibited" on some attributes to
       get rid of them. But I'm gonna skip it for now -->

  <xsd:attribute name="parseType"/>
  <xsd:attributeGroup name="parseLiteral">
    <xsd:attribute name="parseType" fixed="Literal" />
    <xsd:attribute ref="parseType" fixed="Literal" />
  </xsd:attributeGroup>

  <xsd:attributeGroup name="parseResource">
    <xsd:attribute name="parseType"  fixed="Resource" />
    <xsd:attribute ref="parseType"  fixed="Resource" />
  </xsd:attributeGroup>

  <!-- so much for syntax structure. Now for the particular
       properties and classes... -->

  <xsd:element name="Statement"
	   type="typedNodeType" />

  <xsd:element name="Property"
           type="typedNodeType" />

	   <!-- these are is constrained to use resource="...";
		use xsi:type to do something else -->
  <xsd:element name="subject"
	   type="propertyEltRef" />

  <xsd:element name="predicate"
	   type="propertyEltRef" />

  <xsd:element name="object"
	   type="propertyEltRef" />

  <xsd:element name="type"
	   type="propertyEltRef" />

  <!-- constrained to the <value>...</value> syntax -->
  <xsd:element name="value"
	   type="valueString" />

</xsd:schema>
